/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2010 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package ci.android.moduleone;

import io.card.payment.CardIOActivity;
import io.card.payment.CreditCard;

import java.util.HashMap;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollProxy;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.titanium.util.TiActivityResultHandler;
import org.appcelerator.titanium.util.TiActivitySupport;
import org.appcelerator.titanium.util.TiConvert;
import org.appcelerator.titanium.util.TiIntentWrapper;

import android.app.Activity;
import android.content.Intent;

// This proxy can be created by calling CodestrongAndroid.createExample({message: "hello world"})
@Kroll.proxy(creatableInModule = CodestrongAndroidModule.class)
public class CardIOProxy extends KrollProxy {
	// Standard Debugging variables
	private static final String LCAT = "CodestrongAndroidModule";
	private int MY_SCAN_REQUEST_CODE = 100; // arbitrary int

	// Constructor
	public CardIOProxy() {
		super();
	}

	public CardIOProxy create(KrollDict options) {
		Log.d(LCAT, "inside CardIOProxy create");
		return this;
	}

	// Handle creation options
	@Override
	public void handleCreationDict(KrollDict options) {
		super.handleCreationDict(options);
	}

	// Methods
	private KrollFunction getCallback(final KrollDict options, final String name)
			throws Exception {
		Object callback = options.get(name);
		if ((callback != null) && (callback instanceof KrollFunction)) {
			return (KrollFunction) callback;
		} else {
			Log.d(LCAT, "Callback not found: " + name);
			throw new Exception("Callback not found: " + name);
		}
	}

	/**
	 * main method for the module to return the users lat lng information from
	 * the skyhook api service
	 * 
	 * @param args
	 * @throws Exception
	 */
	@Kroll.method(runOnUiThread = true)
	public void doScan(HashMap args) throws Exception {
		Log.d(LCAT, "inside CardIOProxy doScan");
		final KrollProxy that = this;

		// set up the callbacks for when the scan is completed
		KrollDict options = new KrollDict(args);
		final KrollFunction successCallback = getCallback(options, "success");
		final KrollFunction cancelCallback = getCallback(options, "error");

		// This method is set up as an onClick handler in the layout xml
		// e.g. android:onClick="onScanPress"

		final Activity activity = this.getActivity();
		final TiActivitySupport activitySupport = (TiActivitySupport) activity;

		final TiIntentWrapper scanIntent = new TiIntentWrapper(new Intent(
				activity, CardIOActivity.class));
		scanIntent.setWindowId(TiIntentWrapper.createActivityName("TiCARDIO"));

		Log.d(LCAT,
				"CardIOActivity.EXTRA_APP_TOKEN "
						+ TiConvert.toString(getProperty("APP_TOKEN")));
		// required for authentication with card.io
		scanIntent
				.getIntent()
				.putExtra(CardIOActivity.EXTRA_APP_TOKEN,
						TiConvert.toString(getProperty("APP_TOKEN"))/* MY_CARDIO_APP_TOKEN */);

		// customize these values to suit your needs.
		scanIntent.getIntent().putExtra(CardIOActivity.EXTRA_REQUIRE_EXPIRY,
				TiConvert.toBoolean(getProperty("REQUIRE_EXPIRY"))); // default:
		// true
		scanIntent.getIntent().putExtra(CardIOActivity.EXTRA_REQUIRE_CVV,
				TiConvert.toBoolean(getProperty("REQUIRE_CVV"))); // default:
		// false
		scanIntent.getIntent().putExtra(CardIOActivity.EXTRA_REQUIRE_ZIP,
				TiConvert.toBoolean(getProperty("REQUIRE_ZIP")));// default:
		// false

		// hides the manual entry button
		// if set, developers should provide their own manual entry mechanism in
		// the app
		scanIntent.getIntent().putExtra(
				CardIOActivity.EXTRA_SUPPRESS_MANUAL_ENTRY,
				TiConvert.toBoolean(getProperty("SUPPRESS_MANUAL_ENTRY"))); // default:
		// false

		// MY_SCAN_REQUEST_CODE is arbitrary and is only used within this
		// activity.

		CardIOResultHandler resultHandler = new CardIOResultHandler();

		resultHandler.successCallback = successCallback;
		resultHandler.cancelCallback = cancelCallback;
		resultHandler.activitySupport = activitySupport;
		resultHandler.scanIntent = scanIntent.getIntent();
		activity.runOnUiThread(resultHandler);

	}

	protected class CardIOResultHandler implements TiActivityResultHandler,
			Runnable {

		protected int code;
		protected KrollFunction successCallback, cancelCallback;
		protected TiActivitySupport activitySupport;
		protected KrollProxy proxy;
		protected Intent scanIntent;

		public void run() {
			Log.d(LCAT, "inside CardIOResultHandler run");
			code = activitySupport.getUniqueResultCode();
			activitySupport.launchActivityForResult(scanIntent, code, this);
		}

		public void onError(Activity activity, int requestCode, Exception e) {
			String msg = "Problem with scanner; " + e.getMessage();
			Log.d(LCAT, "inside CardIOResultHandler onError " + msg);
		}

		public void onResult(Activity activity, int requestCode,
				int resultCode, Intent data) {
			String resultStr;
			HashMap<String, String> callbackDict = new HashMap<String, String>();

			// process the results
			if (data != null && data.hasExtra(CardIOActivity.EXTRA_SCAN_RESULT)) {
				CreditCard scanResult = data
						.getParcelableExtra(CardIOActivity.EXTRA_SCAN_RESULT);

				// Never log a raw card number. Avoid displaying it, but if
				// necessary use getFormattedCardNumber()
				resultStr = "Card Number: "
						+ scanResult.getRedactedCardNumber() + "\n";

				// Do something with the raw number, e.g.:
				// myService.setCardNumber( scanResult.cardNumber );

				if (scanResult.isExpiryValid()) {
					resultStr += "Expiration Date: " + scanResult.expiryMonth
							+ "/" + scanResult.expiryYear + "\n";
				}

				if (scanResult.cvv != null) {
					// Never log or display a CVV
					resultStr += "CVV has " + scanResult.cvv.length()
							+ " digits.\n";
				}

				if (scanResult.zip != null) {
					resultStr += "Zip: " + scanResult.zip + "\n";
				}

				// get all of the data in a hash for returning
				callbackDict.put("success", "true");
				callbackDict.put("cvv", (scanResult.cvv.length() != 0 ? "true"
						: "false"));
				callbackDict.put("expiryMonth",
						(scanResult.expiryMonth != 0 ? scanResult.expiryMonth
								+ "" : null));
				callbackDict.put("zip",
						(scanResult.zip.length() != 0 ? scanResult.zip : null));
				callbackDict.put("expiryYear",
						(scanResult.expiryYear != 0 ? scanResult.expiryYear
								+ "" : null));
				callbackDict
						.put("redactedCard",
								(scanResult.getRedactedCardNumber().length() != 0 ? scanResult
										.getRedactedCardNumber() : null));

				// callback if necessary and just log the error
				if (cancelCallback != null) {
					cancelCallback.callAsync(getKrollObject(), callbackDict);
				}

			} else {
				resultStr = "Scan was canceled.";

				callbackDict.put("success", "false");
				callbackDict.put("cancelled", resultStr);

				// callback if necessary and just log the error
				if (cancelCallback != null) {
					cancelCallback.callAsync(getKrollObject(), callbackDict);
				}

			}
			Log.d(LCAT, "Scan results: " + resultStr);
		}
	}

}